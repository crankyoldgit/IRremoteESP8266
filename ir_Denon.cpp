#include "IRremote.h"
#include "IRremoteInt.h"

// Reverse Engineered by looking at RAW dumps generated by IRremote

// I have since discovered that Denon publish all their IR codes:
//  https://www.google.co.uk/search?q=DENON+MASTER+IR+Hex+Command+Sheet
//  -> http://assets.denon.com/documentmaster/us/denon%20master%20ir%20hex.xls

// Having looked at the official Denon Pronto sheet and reverse engineered
// the timing values from it, it is obvious that Denon have a range of
// different timings and protocols ...the values here work for my AVR-3801 Amp!

//==============================================================================
//                    DDDD   EEEEE  N   N   OOO   N   N
//                     D  D  E      NN  N  O   O  NN  N
//                     D  D  EEE    N N N  O   O  N N N
//                     D  D  E      N  NN  O   O  N  NN
//                    DDDD   EEEEE  N   N   OOO   N   N
//==============================================================================

#define BITS          14  // The number of bits in the command
#define HDR_MARK     300  // The length of the Header:Mark
#define HDR_SPACE    750  // The lenght of the Header:Space
#define BIT_MARK     300  // The length of a Bit:Mark
#define ONE_SPACE   1800  // The length of a Bit:Space for 1's
#define ZERO_SPACE   750  // The length of a Bit:Space for 0's
// Same as SHARP with first bit on 

//+=============================================================================
//
#if SEND_DENON
void  IRsend::sendDenon (unsigned long data,  int nbits)
{
	// Set IR carrier frequency
	enableIROut(38);

	// Header
	mark (HDR_MARK);
	space(HDR_SPACE);

	// Data
	for (unsigned long  mask = 1UL << (nbits - 1);  mask;  mask >>= 1) {
		mark (BIT_MARK);
		space_encode(data & mask, ONE_SPACE, ZERO_SPACE);
	}

	// Footer
	mark(BIT_MARK);
	space(0);  // Always end with the LED off
}
#endif

//+=============================================================================
//
#if DECODE_DENON
bool  IRrecv::decodeDenon (decode_results *results)
{
	unsigned long  data   = 0;  // Somewhere to build our code
	int            offset = OFFSET_START;  // Skip the Gap reading

	// Check we have the right amount of data
	if (irparams.rawlen != 1 + 2 + (2 * BITS) + OFFSET_START)  return false ;

	// Check initial Mark+Space match
	if (!MATCH_MARK (results->rawbuf[offset++], HDR_MARK ))  return false ;
	if (!MATCH_SPACE(results->rawbuf[offset++], HDR_SPACE))  return false ;

	// Read the bits in
	for (int i = 0;  i < BITS;  i++) {
		if (!MATCH_MARK(results->rawbuf[offset++], BIT_MARK))                      return false ;
		if (!space_decode(data,results->rawbuf[offset++], ONE_SPACE, ZERO_SPACE))  return false ;
	}

	// Success
	results->bits        = BITS;
	results->value       = data;
	results->decode_type = DENON;
	return true;
}
#endif
